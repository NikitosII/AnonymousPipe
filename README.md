# AnonymousPipe
![C](https://img.shields.io/badge/C-blue.svg)

Проект демонстрирует различные методы синхронизации потоков с использованием pipe. 
В проекте рассматривается вид взаимодействия, когда потоки неравноправны, когда один поток записывает данные, а другой поток их читает.

## Описание

Многопоточность характерна тем, что нельзя предсказать, в какой точке программы находится поток в произвольный момент времени. Потоки прерываются, передают управление от одного к другому, блокируются, создаются, уничтожаются.
Поэтому нет гарантии в последовательной очередности действий «записать данные в А» и «прочитать данные из А».

Могут возникать проблемы синхронизации:
- Если читающий поток задержался, пишущий поток может многократно записывать данные, стирая ранее записанные.
- Если пишущий поток задержался, читающий поток может читать данные из пустой ячейки.

Для решения проблем можно использовать неименованный канал.
*Pipe* — это средство, которое поддерживает ограничения: не записывать данные в ячейку, если не прочитаны ранее записанные данные; не читать данные из ячейки, если в нее не записаны данные.

Как правило, один поток пишет данные в pipe, а второй поток читает данные из pipe.

Если pipe пустой (данные не записаны), то поток, читающий данные, **блокируется**, пока второй поток не запишет данные.
Если pipe полный, то есть данные никто не читает, то поток, записывающий данные **блокируется**, пока другой поток не прочитает данные и не освободит, тем самым, место под запись.

**file3.c**

В программе есть возможность через аргумент командной строки инициализации неименованного канала одним из трех способов:
1.	вызовом pipe(), при котором запись и чтение выполняются с блокировками;
2.	вызовом pipe2(), при котором запись и чтение выполняются без блокировок;
3.	вызовом pipe() в сочетании с fcntl(), при котором запись и чтение выполняются без блокировок.

В качестве сообщения передаются данные, получаемые функцией long gethostid(void) — получить уникальный идентификатор текущей машины и
передавать его.

Глобальные переменные:
- volatile sig_atomic_t flag1: Флаг для остановки первого потока.
- volatile sig_atomic_t flag2: Флаг для остановки второго потока.
- int pipe_fd[2]: Неименованный канал; массив из двух файловых дескрипторов, один для записи (filedes[1]), другой для чтения (filedes[0]).

Обработчик сигнала:
- sig_handler: Обработчик сигнала SIGINT, который устанавливает флаги для остановки потоков, закрывает дескрипторы pipe и завершает программу.
  
Функции потоков:
- func1: Функция первого потока. Записывает сообщение с ID хоста в pipe.
- func2: Функция второго потока. Читает сообщение из pipe и выводит его.    

Для устранения блокировок используются неблокирующие операции чтения и записи:
- Создание неблокирующего pipe: int pipe2(int pipe_fd, int flags), где flags — значение O_NONBLOCK для неблокирующего режима.
- Установка флагов состояния дескрипторов: int fcntl(int fd, int cmd, ... /* arg */ ), где cmd — команда F_SETFL для установки флагов и arg — флаг O_NONBLOCK.
  
## Использование

1. Склонируйте репозиторий:
    ```sh
    git clone <URL репозитория>
    ```
2. Перейдите в директорию проекта:
    ```sh
    cd <имя директории проекта>
    ```
3. Сделайте скрипт исполняемым:
    ```sh
    chmod +x file3.sh
    ```
4. Запустите скрипт:
    ```sh
    ./file3.sh 1  # Для режима 1 (pipe с блокировкой)
    ./file3.sh 2  # Для режима 2 (pipe2 без блокировок)
    ./file3.sh 3  # Для режима 3 (pipe + fcntl без блокировок)
    ```

## Структура проекта

- file3.c: Основной файл программы, содержащий реализацию синхронизации потоков с использованием pipe.
- file3.sh: Скрипт для компиляции и запуска программы.


